const fs = require('fs-extra');
const path = require('node:path');
const chalk = require('chalk');
const os = require('os');

/**
 * Orchestrator Module Installer
 * Sets up the orchestrator module including registry initialization
 *
 * @param {Object} options - Installation options
 * @param {string} options.projectRoot - The root directory of the target project
 * @param {Object} options.config - Module configuration from module.yaml
 * @param {Array<string>} options.installedIDEs - Array of IDE codes that were installed
 * @param {Object} options.logger - Logger instance for output
 * @returns {Promise<boolean>} - Success status
 */
async function install(options) {
  const { projectRoot, config, installedIDEs, logger } = options;

  try {
    logger.log(chalk.blue('ðŸŽ¯ Installing Orchestrator Module...'));

    // 1. Initialize the global registry directory
    await initializeRegistry(config, logger);

    // 2. Create orchestrator config directory
    const configDir = path.join(projectRoot, '_bmad', 'orchestrator');
    if (!(await fs.pathExists(configDir))) {
      logger.log(chalk.yellow('  Creating orchestrator config directory'));
      await fs.ensureDir(configDir);
    }

    // 3. Create the orchestrator config.yaml if it doesn't exist
    const configPath = path.join(configDir, 'config.yaml');
    if (!(await fs.pathExists(configPath))) {
      await createOrchestratorConfig(configPath, config, logger);
    }

    // 4. Auto-register this project if not already registered
    await autoRegisterProject(projectRoot, config, logger);

    // 5. Handle IDE-specific configurations
    if (installedIDEs && installedIDEs.length > 0) {
      logger.log(chalk.cyan(`  Configuring Orchestrator for IDEs: ${installedIDEs.join(', ')}`));

      for (const ide of installedIDEs) {
        await configureForIDE(ide, projectRoot, config, logger);
      }
    }

    // 6. Check Docker availability for memory features
    if (config['memory_enabled'] !== false) {
      await checkDockerAvailability(logger);
    }

    logger.log(chalk.green('âœ“ Orchestrator Module installation complete'));
    return true;
  } catch (error) {
    logger.error(chalk.red(`Error installing Orchestrator module: ${error.message}`));
    return false;
  }
}

/**
 * Initialize the global registry directory at ~/.bmad/
 */
async function initializeRegistry(config, logger) {
  const registryPath = config['registry_path'] || path.join(os.homedir(), '.bmad');
  const resolvedPath = registryPath.replace('~', os.homedir());

  if (!(await fs.pathExists(resolvedPath))) {
    logger.log(chalk.yellow(`  Creating registry directory: ${resolvedPath}`));
    await fs.ensureDir(resolvedPath);
  }

  const registryFile = path.join(resolvedPath, 'registry.yaml');
  if (!(await fs.pathExists(registryFile))) {
    logger.log(chalk.yellow('  Creating empty project registry'));
    const defaultRegistry = `# BMAD Orchestrator Project Registry
# Auto-generated by orchestrator installer

version: "1.0"
last_updated: "${new Date().toISOString()}"
active_project: null

projects: {}
`;
    await fs.writeFile(registryFile, defaultRegistry, 'utf8');
  }
}

/**
 * Create the orchestrator config.yaml file
 */
async function createOrchestratorConfig(configPath, config, logger) {
  logger.log(chalk.yellow('  Creating orchestrator configuration'));

  const orchestratorConfig = `# BMAD Orchestrator Configuration
# Generated during installation

# Memory settings
memory_enabled: ${config['memory_enabled'] !== false}
memory_docker_port: ${config['memory_docker_port'] || '8000'}

# Quality Gate settings
quality_gate_enabled: ${config['quality_gate_enabled'] !== false}
quality_gate_strict: ${config['quality_gate_strict'] === true}

# Background delegation settings
background_delegation_enabled: ${config['background_delegation_enabled'] !== false}

# Intent detection settings
intent_confidence_threshold: 0.80
intent_clarify_threshold: 0.60
`;

  await fs.writeFile(configPath, orchestratorConfig, 'utf8');
}

/**
 * Auto-register this project in the registry
 */
async function autoRegisterProject(projectRoot, config, logger) {
  const registryPath = config['registry_path'] || path.join(os.homedir(), '.bmad');
  const resolvedPath = registryPath.replace('~', os.homedir());
  const registryFile = path.join(resolvedPath, 'registry.yaml');

  try {
    const yaml = require('yaml');
    const content = await fs.readFile(registryFile, 'utf8');
    const registry = yaml.parse(content);

    // Check if already registered
    const existingProject = Object.values(registry.projects || {}).find(
      p => p.path === projectRoot
    );

    if (!existingProject) {
      logger.log(chalk.yellow('  Auto-registering project in orchestrator registry'));

      const projectId = generateProjectId();
      const projectName = config['project_name'] || path.basename(projectRoot);

      registry.projects = registry.projects || {};
      registry.projects[projectId] = {
        name: projectName,
        path: projectRoot,
        type: detectProjectType(projectRoot),
        created: new Date().toISOString(),
        last_accessed: new Date().toISOString(),
        modules_installed: ['orchestrator']
      };

      // Set as active if no active project
      if (!registry.active_project) {
        registry.active_project = projectId;
      }

      registry.last_updated = new Date().toISOString();
      await fs.writeFile(registryFile, yaml.stringify(registry), 'utf8');

      logger.log(chalk.green(`  âœ“ Registered project: ${projectName} (${projectId})`));
    } else {
      logger.log(chalk.dim('  Project already registered in orchestrator'));
    }
  } catch (error) {
    logger.warn(chalk.yellow(`  Warning: Could not auto-register project: ${error.message}`));
  }
}

/**
 * Generate a short project ID
 */
function generateProjectId() {
  return Math.random().toString(36).substring(2, 10);
}

/**
 * Detect project type from filesystem
 */
function detectProjectType(projectRoot) {
  const fs = require('fs');

  // Check for game project markers
  if (fs.existsSync(path.join(projectRoot, 'project.godot'))) return 'game';
  if (fs.existsSync(path.join(projectRoot, 'Assets', 'Scenes'))) return 'game'; // Unity

  // Check for library markers
  if (fs.existsSync(path.join(projectRoot, 'setup.py'))) return 'library';

  // Default to product
  return 'product';
}

/**
 * Check if Docker is available for memory features
 */
async function checkDockerAvailability(logger) {
  const { exec } = require('child_process');
  const { promisify } = require('util');
  const execAsync = promisify(exec);

  try {
    await execAsync('docker --version');
    logger.log(chalk.green('  âœ“ Docker available for memory features'));
  } catch {
    logger.warn(chalk.yellow('  âš  Docker not found. Memory features will be disabled.'));
    logger.warn(chalk.yellow('    Install Docker to enable per-project memory.'));
  }
}

/**
 * Configure Orchestrator module for specific platform/IDE
 */
async function configureForIDE(ide, projectRoot, config, logger) {
  // Try to load platform-specific handler
  const platformSpecificPath = path.join(__dirname, 'platform-specifics', `${ide}.js`);

  try {
    if (await fs.pathExists(platformSpecificPath)) {
      const platformHandler = require(platformSpecificPath);

      if (typeof platformHandler.install === 'function') {
        await platformHandler.install({
          projectRoot,
          config,
          logger
        });
      }
    } else {
      // No platform-specific handler for this IDE
      logger.log(chalk.dim(`  No Orchestrator-specific configuration for ${ide}`));
    }
  } catch (error) {
    logger.warn(chalk.yellow(`  Warning: Could not load Orchestrator platform handler for ${ide}: ${error.message}`));
  }
}

module.exports = { install };
